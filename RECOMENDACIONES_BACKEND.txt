================================================================================
RECOMENDACIONES DE OPTIMIZACIÓN PARA EL BACKEND - CRM CAZADOR
================================================================================

Este documento contiene recomendaciones priorizadas para mejorar el rendimiento,
la experiencia de usuario y la eficiencia del backend de la aplicación CRM Cazador.

Fecha: 2025-01-09
Framework: Laravel 12
Versión API actual: Sin versionado
Base URL: /api/cazador

NOTA: Este documento se basa en la documentación de ENDPOINTS.md y el análisis
del código del frontend. Algunas funcionalidades pueden estar implementadas pero
no documentadas, o viceversa.

ANÁLISIS DE ESTADO ACTUAL (basado en ENDPOINTS.md):

✅ Ya implementado y documentado:
  - GET /clients con filtros: search, status, type, source
  - GET /projects con múltiples filtros avanzados
  - GET /projects/{id} con include_units y units_per_page
  - GET /dateros con search e is_active
  - POST /reservations/{id}/confirm con multipart/form-data
  - Autenticación JWT con refresh token

⚠️ Implementado pero NO documentado:
  - GET /clients con create_type (usado por frontend, falta en ENDPOINTS.md)

❌ Falta implementar:
  - GET /reservations solo tiene per_page (sin filtros)
  - GET /dashboard/stats (endpoint no existe)
  - Headers de caché HTTP
  - Compresión de respuestas (no documentado)
  - Endpoints batch
  - Endpoints de validación previa
  - Manejo de relaciones con include genérico (solo include_units en projects)
  - Búsqueda mejorada (full-text, fuzzy, etc.)
  - Endpoints de exportación
  - Endpoint de sincronización
  - Health check endpoints

================================================================================
PRIORIDAD ALTA - IMPACTO INMEDIATO
================================================================================

NOTA PREVIA: Revisar ENDPOINTS.md para verificar qué funcionalidades ya están
implementadas pero no documentadas. El frontend usa create_type en clientes,
pero no está documentado en ENDPOINTS.md.

RESUMEN DE ESTADO ACTUAL (basado en ENDPOINTS.md):

✅ Ya implementado y documentado:
  - GET /clients con filtros: search, status, type, source
  - GET /projects con múltiples filtros avanzados (9 filtros diferentes)
  - GET /projects/{id} con include_units y units_per_page
  - GET /dateros con search e is_active
  - POST /reservations/{id}/confirm con multipart/form-data
  - Autenticación JWT con refresh token
  - POST /clients/{client}/activities (crear actividades)

⚠️ Implementado pero NO documentado en ENDPOINTS.md:
  - GET /clients con create_type datero, propio (usado por frontend, falta documentar)

❌ Falta implementar (confirmado en ENDPOINTS.md):
  - GET /reservations solo tiene per_page (sin filtros: search, status, payment_status, etc.)
  - GET /dashboard/stats (endpoint no existe)
  - Headers de caché HTTP (no mencionados)
  - Compresión de respuestas (no documentado)
  - Endpoints batch
  - Endpoints de validación previa
  - Manejo de relaciones con include genérico (solo include_units en projects)
  - Búsqueda mejorada (full-text, fuzzy, autocompletado)
  - Endpoints de exportación
  - Endpoint de sincronización
  - Health check endpoints

1. AGREGAR FILTROS AL ENDPOINT DE RESERVAS
--------------------------------------------------------------------------------
Problema: Según ENDPOINTS.md, GET /cazador/reservations solo acepta per_page.
El filtrado por status, payment_status, project_id, client_id, advisor_id y 
búsqueda se hace en el cliente, lo cual es ineficiente.

Solución Laravel: Usar FormRequest y Query Scopes en el modelo Reservation

Implementación:
  a) Crear ReservationIndexRequest:
     app/Http/Requests/Cazador/ReservationIndexRequest.php
     - Validar parámetros: search, status, payment_status, project_id, client_id, advisor_id
     - Aplicar reglas de autorización si es necesario

  b) Agregar Query Scopes al modelo Reservation:
     app/Models/Reservation.php
     
     public function scopeSearch($query, $search) {
         return $query->where(function($q) use ($search) {
             $q->where('reservation_number', 'like', "%{$search}%")
               ->orWhereHas('client', fn($q) => $q->where('name', 'like', "%{$search}%"))
               ->orWhereHas('project', fn($q) => $q->where('name', 'like', "%{$search}%"));
         });
     }
     
     public function scopeByStatus($query, $status) {
         return $query->where('status', $status);
     }
     
     public function scopeByPaymentStatus($query, $paymentStatus) {
         return $query->where('payment_status', $paymentStatus);
     }
     
     public function scopeByProject($query, $projectId) {
         return $query->where('project_id', $projectId);
     }
     
     public function scopeByClient($query, $clientId) {
         return $query->where('client_id', $clientId);
     }
     
     public function scopeByAdvisor($query, $advisorId) {
         return $query->where('advisor_id', $advisorId);
     }

  c) Actualizar ReservationController@index:
     $reservations = Reservation::query()
         ->when($request->filled('search'), fn($q) => $q->search($request->search))
         ->when($request->filled('status'), fn($q) => $q->byStatus($request->status))
         ->when($request->filled('payment_status'), fn($q) => $q->byPaymentStatus($request->payment_status))
         ->when($request->filled('project_id'), fn($q) => $q->byProject($request->project_id))
         ->when($request->filled('client_id'), fn($q) => $q->byClient($request->client_id))
         ->when($request->filled('advisor_id'), fn($q) => $q->byAdvisor($request->advisor_id))
         ->with(['client', 'project', 'unit'])
         ->paginate($request->per_page ?? 15);

Beneficio: Reducción de datos transferidos, mejor rendimiento, búsquedas más rápidas.

Ejemplo:
  GET /api/cazador/reservations?status=activa&payment_status=pendiente&search=maria


2. ENDPOINT DE ESTADÍSTICAS DEL DASHBOARD
--------------------------------------------------------------------------------
Problema: El dashboard necesita 4 requests separadas para obtener contadores:
  - GET /cazador/clients (para contar)
  - GET /cazador/dateros (para contar)
  - GET /cazador/projects (para contar)
  - GET /cazador/reservations (para contar)
  
Esto es ineficiente y lento.

Solución Laravel: Crear DashboardController con caché usando Cache::remember

Implementación:
  a) Crear DashboardController:
     app/Http/Controllers/Cazador/DashboardController.php
     
     public function stats(Request $request) {
         $cacheKey = 'dashboard_stats_' . auth()->id();
         
         $stats = Cache::remember($cacheKey, 300, function () {
             return [
                 'clients' => [
                     'total' => Client::where('advisor_id', auth()->id())->count(),
                     'by_status' => Client::where('advisor_id', auth()->id())
                         ->selectRaw('status, count(*) as count')
                         ->groupBy('status')
                         ->pluck('count', 'status'),
                     'by_type' => Client::where('advisor_id', auth()->id())
                         ->selectRaw('type, count(*) as count')
                         ->groupBy('type')
                         ->pluck('count', 'type'),
                 ],
                 'dateros' => [
                     'total' => Datero::where('lider_id', auth()->id())->count(),
                     'active' => Datero::where('lider_id', auth()->id())
                         ->where('is_active', true)->count(),
                     'inactive' => Datero::where('lider_id', auth()->id())
                         ->where('is_active', false)->count(),
                 ],
                 'projects' => [
                     'total' => Project::count(),
                     'with_available_units' => Project::has('availableUnits')->count(),
                 ],
                 'reservations' => [
                     'total' => Reservation::where('advisor_id', auth()->id())->count(),
                     'by_status' => Reservation::where('advisor_id', auth()->id())
                         ->selectRaw('status, count(*) as count')
                         ->groupBy('status')
                         ->pluck('count', 'status'),
                     'by_payment_status' => Reservation::where('advisor_id', auth()->id())
                         ->selectRaw('payment_status, count(*) as count')
                         ->groupBy('payment_status')
                         ->pluck('count', 'payment_status'),
                 ],
             ];
         });
         
         return response()->json(['data' => $stats]);
     }

  b) Agregar ruta en routes/api.php:
     Route::get('/cazador/dashboard/stats', [DashboardController::class, 'stats'])
         ->middleware(['auth:api', 'cazador']);

  c) Invalidar caché cuando se crean/actualizan recursos:
     Usar Events y Listeners para limpiar caché:
     - ClientCreated, ClientUpdated -> limpiar dashboard_stats
     - ReservationCreated, ReservationUpdated -> limpiar dashboard_stats
     - etc.

Respuesta esperada:
{
  "data": {
    "clients": {
      "total": 150,
      "by_status": { "nuevo": 50, "contactado": 30 },
      "by_type": { "comprador": 100, "vendedor": 50 }
    },
    "dateros": {
      "total": 25,
      "active": 20,
      "inactive": 5
    },
    "projects": {
      "total": 10,
      "with_available_units": 8
    },
    "reservations": {
      "total": 45,
      "by_status": { "activa": 20, "confirmada": 15 },
      "by_payment_status": { "pendiente": 10, "pagado": 35 }
    }
  }
}

Beneficio: Reducción de 75% en requests (de 4 a 1), carga más rápida, menos carga en BD.


3. HEADERS DE CACHÉ HTTP
--------------------------------------------------------------------------------
Problema: No se detectan headers de caché en las respuestas.

Solución Laravel: Crear Middleware para agregar headers de caché

Implementación:
  a) Crear CacheHeaders Middleware:
     app/Http/Middleware/CacheHeaders.php
     
     public function handle($request, Closure $next, $maxAge = 300) {
         $response = $next($request);
         
         if ($request->isMethod('GET') && $response->getStatusCode() === 200) {
             $etag = md5($response->getContent());
             $lastModified = now()->toRfc7231String();
             
             $response->headers->set('Cache-Control', "public, max-age={$maxAge}");
             $response->headers->set('ETag', "\"{$etag}\"");
             $response->headers->set('Last-Modified', $lastModified);
             $response->headers->set('Vary', 'Accept, Authorization');
             
             // Validación condicional
             if ($request->header('If-None-Match') === "\"{$etag}\"") {
                 return response()->json([], 304);
             }
         }
         
         return $response;
     }

  b) Registrar middleware en bootstrap/app.php o Kernel:
     ->middleware(CacheHeaders::class)

  c) Aplicar a rutas específicas con diferentes tiempos:
     Route::middleware(['cache.headers:300'])->group(function () {
         // Rutas con caché de 5 minutos
     });
     
     Route::middleware(['cache.headers:60'])->group(function () {
         // Rutas con caché de 1 minuto
     });

Ejemplo de headers:
  Cache-Control: public, max-age=300
  ETag: "abc123def456"
  Last-Modified: Wed, 09 Jan 2025 10:00:00 GMT
  Vary: Accept, Authorization

Beneficio: Menos requests innecesarios (304 Not Modified), mejor rendimiento.


4. COMPRESIÓN DE RESPUESTAS
--------------------------------------------------------------------------------
Problema: No se menciona compresión de respuestas.

Solución Laravel: Configurar compresión en servidor web + middleware opcional

Implementación:
  a) Configurar Nginx (recomendado):
     En nginx.conf o site config:
     
     gzip on;
     gzip_vary on;
     gzip_proxied any;
     gzip_comp_level 6;
     gzip_types text/plain text/css text/xml text/javascript 
                application/json application/javascript application/xml+rss 
                application/rss+xml font/truetype font/opentype 
                application/vnd.ms-fontobject image/svg+xml;
     gzip_min_length 1000;
     
     # Brotli (opcional, requiere módulo)
     brotli on;
     brotli_comp_level 6;
     brotli_types text/plain text/css text/xml text/javascript 
                  application/json application/javascript application/xml+rss;

  b) Middleware opcional para compresión manual (si no se usa Nginx):
     app/Http/Middleware/CompressResponse.php
     
     public function handle($request, Closure $next) {
         $response = $next($request);
         
         if ($request->wantsJson() && strlen($response->getContent()) > 1000) {
             $content = gzencode($response->getContent(), 6);
             return response($content)
                 ->header('Content-Encoding', 'gzip')
                 ->header('Content-Length', strlen($content));
         }
         
         return $response;
     }

  c) Verificar que Laravel acepta Accept-Encoding:
     Ya está soportado por defecto en Laravel 12

Beneficio: Reducción de 60-80% en tamaño de respuestas, menor uso de datos móviles.


5. MEJORAR DOCUMENTACIÓN DE ERRORES
--------------------------------------------------------------------------------
Problema: Los códigos de error HTTP no están completamente documentados.

Solución Laravel: Usar Exception Handler personalizado y API Resources

Implementación:
  a) Personalizar Handler en app/Exceptions/Handler.php:
     
     public function render($request, Throwable $exception) {
         if ($request->wantsJson() || $request->is('api/*')) {
             return $this->handleApiException($request, $exception);
         }
         
         return parent::render($request, $exception);
     }
     
     protected function handleApiException($request, Throwable $exception) {
         $errorId = Str::uuid()->toString();
         
         // Log con error_id
         Log::error("API Error [{$errorId}]: " . $exception->getMessage(), [
             'exception' => $exception,
             'request' => $request->all(),
             'user' => auth()->id(),
         ]);
         
         if ($exception instanceof ValidationException) {
             return response()->json([
                 'error' => [
                     'code' => 'VALIDATION_ERROR',
                     'message' => 'Error de validación',
                     'details' => $exception->errors(),
                     'error_id' => $errorId,
                 ]
             ], 422);
         }
         
         if ($exception instanceof AuthenticationException) {
             return response()->json([
                 'error' => [
                     'code' => 'UNAUTHORIZED',
                     'message' => 'Token expirado o inválido',
                     'error_id' => $errorId,
                 ]
             ], 401);
         }
         
         if ($exception instanceof AuthorizationException) {
             return response()->json([
                 'error' => [
                     'code' => 'FORBIDDEN',
                     'message' => 'No tienes permiso para realizar esta acción',
                     'error_id' => $errorId,
                 ]
             ], 403);
         }
         
         if ($exception instanceof ModelNotFoundException) {
             return response()->json([
                 'error' => [
                     'code' => 'NOT_FOUND',
                     'message' => 'Recurso no encontrado',
                     'error_id' => $errorId,
                 ]
             ], 404);
         }
         
         // Error genérico
         return response()->json([
             'error' => [
                 'code' => 'INTERNAL_ERROR',
                 'message' => config('app.debug') 
                     ? $exception->getMessage() 
                     : 'Error interno del servidor',
                 'error_id' => $errorId,
             ]
         ], 500);
     }

  b) Crear Exceptions personalizadas:
     app/Exceptions/ApiException.php
     app/Exceptions/ValidationException.php (ya existe, personalizar)
     app/Exceptions/ResourceNotFoundException.php

  c) Documentar en ENDPOINTS.md todos los códigos posibles

Formato estándar de errores:
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Error de validación",
    "details": {
      "field": ["mensaje de error específico"]
    },
    "error_id": "abc123" // Para tracking en logs
  }
}

Beneficio: Mejor manejo de errores en el cliente, debugging más fácil, tracking de errores.


================================================================================
PRIORIDAD MEDIA - MEJORAS IMPORTANTES
================================================================================

6. RATE LIMITING MEJORADO
--------------------------------------------------------------------------------
Solución Laravel: Usar RateLimiter de Laravel con middleware personalizado

Implementación:
  a) Configurar límites en bootstrap/app.php o RouteServiceProvider:
     
     RateLimiter::for('api', function (Request $request) {
         return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
     });
     
     RateLimiter::for('api-get', function (Request $request) {
         return Limit::perMinute(120)->by($request->user()?->id ?: $request->ip());
     });
     
     RateLimiter::for('api-post', function (Request $request) {
         return Limit::perMinute(30)->by($request->user()?->id ?: $request->ip());
     });

  b) Crear middleware RateLimitHeaders:
     app/Http/Middleware/RateLimitHeaders.php
     
     public function handle($request, Closure $next, $limiter = 'api') {
         $key = $request->user()?->id ?: $request->ip();
         $limiter = app(RateLimiter::class);
         
         $response = $next($request);
         
         $limit = $limiter->limiter($limiter)($request);
         $remaining = $limit->remaining ?? 0;
         $reset = $limit->resetAt ?? now()->addMinute();
         
         $response->headers->set('X-RateLimit-Limit', $limit->maxAttempts ?? 60);
         $response->headers->set('X-RateLimit-Remaining', $remaining);
         $response->headers->set('X-RateLimit-Reset', $reset->timestamp);
         
         if ($response->getStatusCode() === 429) {
             $response->headers->set('Retry-After', $reset->diffInSeconds(now()));
         }
         
         return $response;
     }

  c) Aplicar a rutas:
     Route::middleware(['throttle:api-get'])->group(function () {
         Route::get('/clients', ...);
     });
     
     Route::middleware(['throttle:api-post'])->group(function () {
         Route::post('/clients', ...);
     });

Headers informativos:
  - X-RateLimit-Limit: Límite de requests
  - X-RateLimit-Remaining: Requests restantes
  - X-RateLimit-Reset: Tiempo de reset (timestamp)
  - Retry-After: En respuesta 429 (segundos)

Beneficio: Cliente puede adaptar comportamiento, prevención de abuso, mejor experiencia.


7. PAGINACIÓN MEJORADA
--------------------------------------------------------------------------------
Solución Laravel: Extender LengthAwarePaginator y crear Resource para paginación

Implementación:
  a) Crear PaginatedResource:
     app/Http/Resources/PaginatedResource.php
     
     public static function make($paginator) {
         return [
             'data' => $paginator->items(),
             'meta' => [
                 'current_page' => $paginator->currentPage(),
                 'per_page' => $paginator->perPage(),
                 'total' => $paginator->total(),
                 'total_pages' => $paginator->lastPage(),
                 'has_next' => $paginator->hasMorePages(),
                 'has_prev' => $paginator->currentPage() > 1,
                 'links' => [
                     'first' => $paginator->url(1),
                     'last' => $paginator->url($paginator->lastPage()),
                     'prev' => $paginator->previousPageUrl(),
                     'next' => $paginator->nextPageUrl(),
                 ],
             ],
         ];
     }

  b) Usar en controllers:
     $clients = Client::paginate($request->per_page ?? 15);
     return response()->json(PaginatedResource::make($clients));

  c) Paginación cursor-based (para datasets grandes):
     Crear trait CursorPaginator:
     app/Traits/CursorPaginator.php
     
     public function scopeCursorPaginate($query, $cursor = null, $limit = 15) {
         if ($cursor) {
             $query->where('id', '>', $cursor);
         }
         
         $items = $query->limit($limit + 1)->get();
         $hasMore = $items->count() > $limit;
         
         if ($hasMore) {
             $items = $items->take($limit);
         }
         
         return [
             'data' => $items,
             'next_cursor' => $hasMore ? $items->last()->id : null,
             'has_more' => $hasMore,
         ];
     }

Respuesta con metadatos:
{
  "data": [...],
  "meta": {
    "current_page": 1,
    "per_page": 15,
    "total": 150,
    "total_pages": 10,
    "has_next": true,
    "has_prev": false,
    "links": {
      "first": "/api/cazador/clients?page=1",
      "last": "/api/cazador/clients?page=10",
      "prev": null,
      "next": "/api/cazador/clients?page=2"
    }
  }
}

Adicional: Implementar paginación cursor-based como alternativa:
  GET /cazador/clients?cursor=abc123&limit=15

Beneficio: Navegación más fácil, menos cálculos en el cliente, mejor UX.


8. OPTIMIZACIÓN DE QUERIES
--------------------------------------------------------------------------------
Solución Laravel: Migraciones para índices, Eager Loading, Query Caching

Implementación:
  a) Crear migración para índices:
     php artisan make:migration add_indexes_to_optimize_queries
     
     public function up() {
         Schema::table('clients', function (Blueprint $table) {
             $table->index('name');
             $table->index('document_number');
             $table->index('phone');
             $table->index(['status', 'type', 'source']);
             $table->index('advisor_id');
         });
         
         Schema::table('reservations', function (Blueprint $table) {
             $table->index('status');
             $table->index('payment_status');
             $table->index(['client_id', 'project_id']);
             $table->index('advisor_id');
         });
         
         Schema::table('projects', function (Blueprint $table) {
             $table->index('status');
             $table->index('has_available_units');
         });
     }

  b) Usar Eager Loading en controllers:
     // ❌ N+1 Problem
     $clients = Client::all(); // Cada cliente hace query para reservas
     
     // ✅ Eager Loading
     $clients = Client::with(['reservations', 'activities', 'datero'])->get();
     
     // ✅ Eager Loading condicional
     $clients = Client::with(['reservations' => function($query) {
         $query->where('status', 'activa');
     }])->get();

  c) Query Caching con Cache::remember:
     $clients = Cache::remember("clients_list_{$page}", 300, function() {
         return Client::with('reservations')->paginate(15);
     });
     
     // O usar Cache Tags (Redis/Memcached):
     $clients = Cache::tags(['clients'])->remember("clients_list_{$page}", 300, function() {
         return Client::with('reservations')->paginate(15);
     });
     
     // Invalidar cuando se actualiza:
     Cache::tags(['clients'])->flush();

  d) Usar DB::query() para queries complejas:
     $stats = DB::table('clients')
         ->select('status', DB::raw('count(*) as total'))
         ->groupBy('status')
         ->get();

  e) Habilitar Query Logging en desarrollo:
     DB::enableQueryLog();
     // ... queries ...
     Log::info(DB::getQueryLog());

Beneficio: Respuestas más rápidas, menor carga en BD, mejor escalabilidad.


9. ENDPOINTS BATCH
--------------------------------------------------------------------------------
Solución: Crear endpoints batch para operaciones múltiples:
  - POST /cazador/clients/batch - Crear/actualizar múltiples clientes
  - POST /cazador/reservations/batch - Crear múltiples reservas
  - GET /cazador/clients/batch?ids=1,2,3,4 - Obtener múltiples clientes por IDs

Beneficio: Menos requests HTTP, transacciones atómicas, mejor rendimiento.


10. OPTIMIZACIÓN DE SUBIDA DE IMÁGENES
--------------------------------------------------------------------------------
Problema: Las imágenes se suben sin compresión ni optimización en el servidor.

Solución Laravel: Usar Intervention Image + Storage + Jobs para procesamiento

Implementación:
  a) Instalar Intervention Image:
     composer require intervention/image-laravel
     
     php artisan vendor:publish --provider="Intervention\Image\Laravel\ServiceProvider"

  b) Crear Service para procesamiento de imágenes:
     app/Services/ImageService.php
     
     use Intervention\Image\Laravel\Facades\Image;
     use Illuminate\Support\Facades\Storage;
     
     class ImageService {
         public function processAndStore($file, $path = 'images') {
             // Validar
             $this->validateImage($file);
             
             // Procesar y guardar diferentes tamaños
             $filename = Str::uuid() . '.' . $file->getClientOriginalExtension();
             
             $sizes = [
                 'thumbnail' => [150, 150],
                 'small' => [300, 300],
                 'medium' => [800, 800],
                 'original' => null,
             ];
             
             $urls = [];
             
             foreach ($sizes as $size => $dimensions) {
                 $image = Image::read($file);
                 
                 if ($dimensions) {
                     $image->scale(width: $dimensions[0], height: $dimensions[1]);
                 }
                 
                 // Convertir a WebP si es posible
                 $format = $size === 'original' ? null : 'webp';
                 $ext = $format ? 'webp' : $file->getClientOriginalExtension();
                 $sizeFilename = $size === 'original' 
                     ? $filename 
                     : str_replace('.' . $file->getClientOriginalExtension(), ".{$ext}", $filename);
                 
                 $path = "{$path}/{$size}/{$sizeFilename}";
                 
                 Storage::disk('s3')->put($path, (string) $image->encode($format));
                 
                 $urls[$size] = Storage::disk('s3')->url($path);
             }
             
             return [
                 'image_url' => $urls['original'],
                 'image_urls' => $urls,
             ];
         }
         
         protected function validateImage($file) {
             $maxSize = 10 * 1024 * 1024; // 10MB
             $allowedTypes = ['image/jpeg', 'image/png', 'image/jpg', 'image/webp'];
             
             if ($file->getSize() > $maxSize) {
                 throw new \Exception('La imagen excede el tamaño máximo de 10MB');
             }
             
             if (!in_array($file->getMimeType(), $allowedTypes)) {
                 throw new \Exception('Formato de imagen no permitido');
             }
         }
     }

  c) Usar Job para procesamiento asíncrono (opcional):
     php artisan make:job ProcessReservationImage
     
     class ProcessReservationImage implements ShouldQueue {
         public function handle(ImageService $imageService) {
             // Procesar en background
         }
     }

  d) Configurar Storage para S3:
     config/filesystems.php - ya configurado para S3
     
     En .env:
     AWS_ACCESS_KEY_ID=...
     AWS_SECRET_ACCESS_KEY=...
     AWS_DEFAULT_REGION=...
     AWS_BUCKET=...
     AWS_USE_PATH_STYLE_ENDPOINT=false

  e) Usar en ReservationController@confirm:
     $imageService = app(ImageService::class);
     $imageData = $imageService->processAndStore($request->file('image'), 'reservations');
     
     $reservation->update([
         'image_url' => $imageData['image_url'],
         'image_urls' => json_encode($imageData['image_urls']),
     ]);

Respuesta con URLs de diferentes tamaños:
{
  "image_url": "https://cdn.example.com/original.jpg",
  "image_urls": {
    "thumbnail": "https://cdn.example.com/thumb_150.webp",
    "small": "https://cdn.example.com/small_300.webp",
    "medium": "https://cdn.example.com/medium_800.webp",
    "original": "https://cdn.example.com/original.jpg"
  }
}

Beneficio: Menor uso de ancho de banda, carga más rápida, mejor experiencia, menor almacenamiento.


11. CAMPOS SELECTIVOS EN RESPUESTAS (SPARSE FIELDSETS)
--------------------------------------------------------------------------------
Solución Laravel: Usar API Resources con parámetro fields

Implementación:
  a) Crear ClientResource:
     app/Http/Resources/ClientResource.php
     
     public function toArray($request) {
         $fields = $request->get('fields') 
             ? explode(',', $request->get('fields')) 
             : null;
         
         $data = [
             'id' => $this->id,
             'name' => $this->name,
             'phone' => $this->phone,
             'email' => $this->email,
             'status' => $this->status,
             'type' => $this->type,
             'source' => $this->source,
             // ... todos los campos
         ];
         
         if ($fields) {
             $data = array_intersect_key($data, array_flip($fields));
         }
         
         return $data;
     }

  b) Usar en Controller:
     return ClientResource::collection(
         Client::paginate($request->per_page ?? 15)
     )->additional(['fields' => $request->get('fields')]);

  c) O usar método más simple con select():
     $fields = $request->get('fields') 
         ? explode(',', $request->get('fields')) 
         : ['*'];
     
     $clients = Client::select($fields)->paginate(15);

Ejemplo de uso:
  GET /cazador/clients?fields=id,name,phone,status

Beneficio: Reducción de 30-50% en tamaño de respuestas, menor tiempo de serialización, menor uso de datos.


12. ENDPOINTS DE VALIDACIÓN PREVIA
--------------------------------------------------------------------------------
Solución Laravel: Usar FormRequest para validación reutilizable

Implementación:
  a) Crear StoreClientRequest (ya existe, reutilizar):
     app/Http/Requests/Cazador/StoreClientRequest.php
     
     public function rules() {
         return [
             'name' => 'required|string|min:2|max:255',
             'phone' => 'required|string',
             'document_number' => 'required|string|size:8',
             // ... más reglas
         ];
     }

  b) Crear ValidateClientRequest (solo validación):
     app/Http/Requests/Cazador/ValidateClientRequest.php
     
     // Mismas reglas que StoreClientRequest pero sin autorización

  c) Crear ValidationController:
     app/Http/Controllers/Cazador/ValidationController.php
     
     public function validateClient(ValidateClientRequest $request) {
         // Si llega aquí, la validación pasó
         return response()->json([
             'valid' => true,
             'message' => 'Los datos son válidos',
         ]);
     }
     
     public function validateReservation(Request $request) {
         $validator = Validator::make($request->all(), [
             'unit_id' => 'required|exists:units,id',
             'client_id' => 'required|exists:clients,id',
         ]);
         
         if ($validator->fails()) {
             return response()->json([
                 'valid' => false,
                 'errors' => $validator->errors(),
             ], 422);
         }
         
         // Validar disponibilidad
         $unit = Unit::find($request->unit_id);
         if ($unit->status !== 'disponible') {
             return response()->json([
                 'valid' => false,
                 'errors' => ['unit_id' => ['La unidad no está disponible']],
             ], 422);
         }
         
         return response()->json([
             'valid' => true,
             'message' => 'La reserva puede ser creada',
         ]);
     }
     
     public function validateDni(Request $request) {
         $dni = $request->input('dni');
         
         if (!preg_match('/^[0-9]{8}$/', $dni)) {
             return response()->json([
                 'valid' => false,
                 'errors' => ['dni' => ['El DNI debe tener 8 dígitos']],
             ], 422);
         }
         
         return response()->json([
             'valid' => true,
             'message' => 'Formato de DNI válido',
         ]);
     }

  d) Agregar rutas:
     Route::post('/cazador/clients/validate', [ValidationController::class, 'validateClient']);
     Route::post('/cazador/reservations/validate', [ValidationController::class, 'validateReservation']);
     Route::post('/cazador/documents/validate-dni', [ValidationController::class, 'validateDni']);

Beneficio: Validación en tiempo real, mejor UX, menos requests fallidos, feedback inmediato.


13. MANEJO DE RELACIONES CON INCLUDE
--------------------------------------------------------------------------------
Estado actual: GET /cazador/projects/{id} ya tiene include_units, pero falta
implementar include genérico para otras relaciones.

Solución Laravel: Usar Eager Loading dinámico basado en parámetro include

Implementación:
  a) Crear trait LoadsRelations:
     app/Traits/LoadsRelations.php
     
     trait LoadsRelations {
         protected function loadRelations($query, $request, $allowed = []) {
             if ($request->has('include')) {
                 $includes = explode(',', $request->get('include'));
                 $includes = array_intersect($includes, $allowed);
                 
                 if (!empty($includes)) {
                     $query->with($includes);
                 }
             }
             
             return $query;
         }
     }

  b) Usar en Controller:
     class ClientController extends Controller {
         use LoadsRelations;
         
         public function show(Request $request, $id) {
             $allowedRelations = ['activities', 'reservations', 'notes', 'datero'];
             
             $client = $this->loadRelations(
                 Client::query(),
                 $request,
                 $allowedRelations
             )->findOrFail($id);
             
             return new ClientResource($client);
         }
     }

  c) En Resource, incluir relaciones condicionalmente:
     public function toArray($request) {
         return [
             'id' => $this->id,
             'name' => $this->name,
             'activities' => $this->whenLoaded('activities', function() {
                 return ActivityResource::collection($this->activities);
             }),
             'reservations' => $this->whenLoaded('reservations', function() {
                 return ReservationResource::collection($this->reservations);
             }),
         ];
     }

Ejemplos de uso:
  - GET /cazador/clients/123?include=activities,reservations,notes
  - GET /cazador/projects/456?include=units,reservations
  - GET /cazador/reservations?include=client,project,unit

Beneficio: Reducción de requests (de 3-4 a 1), menor latencia total, mejor rendimiento.


14. ENDPOINTS DE BÚSQUEDA MEJORADOS
--------------------------------------------------------------------------------
Estado actual: Los endpoints ya tienen parámetro search básico:
  - GET /cazador/clients?search=... ✅
  - GET /cazador/dateros?search=... ✅
  - GET /cazador/projects?search=... ✅
  
Pero la búsqueda es básica (LIKE) y puede mejorarse.

Solución Laravel: Implementar búsqueda full-text con:
  - Búsqueda fuzzy (tolerancia a errores tipográficos)
  - Búsqueda por sinónimos
  - Búsqueda por fonética (para nombres similares)
  - Autocompletado con sugerencias

Endpoints de sugerencias:
  - GET /cazador/clients/suggestions?q=mar - Retorna sugerencias mientras escribe
  - GET /cazador/projects/suggestions?q=casa - Sugerencias de proyectos

Beneficio: Búsqueda más intuitiva, mejor experiencia de usuario.


15. LOGGING Y MONITOREO ESTRUCTURADO
--------------------------------------------------------------------------------
Solución Laravel: Middleware de Logging + Integración con Sentry

Implementación:
  a) Crear LogRequest Middleware:
     app/Http/Middleware/LogRequest.php
     
     public function handle($request, Closure $next) {
         $startTime = microtime(true);
         
         $response = $next($request);
         
         $duration = (microtime(true) - $startTime) * 1000; // ms
         
         Log::channel('api')->info('API Request', [
             'method' => $request->method(),
             'url' => $request->fullUrl(),
             'endpoint' => $request->path(),
             'user_id' => auth()->id(),
             'ip' => $request->ip(),
             'status' => $response->getStatusCode(),
             'duration_ms' => round($duration, 2),
             'slow' => $duration > 1000, // > 1 segundo
         ]);
         
         // Log operaciones lentas
         if ($duration > 1000) {
             Log::channel('slow')->warning('Slow API Request', [
                 'endpoint' => $request->path(),
                 'duration_ms' => round($duration, 2),
                 'user_id' => auth()->id(),
             ]);
         }
         
         return $response;
     }

  b) Configurar canales en config/logging.php:
     'channels' => [
         'api' => [
             'driver' => 'daily',
             'path' => storage_path('logs/api.log'),
             'level' => 'info',
             'days' => 14,
         ],
         'slow' => [
             'driver' => 'daily',
             'path' => storage_path('logs/slow-requests.log'),
             'level' => 'warning',
         ],
     ],

  c) Integrar Sentry:
     composer require sentry/sentry-laravel
     
     php artisan sentry:publish
     
     En .env:
     SENTRY_LARAVEL_DSN=...
     
     En AppServiceProvider:
     if (config('sentry.dsn')) {
         Sentry\Laravel\Integration::setup();
     }

  d) Crear comando para métricas:
     php artisan make:command GenerateApiMetrics
     
     // Generar reporte de métricas desde logs

  e) Usar Laravel Telescope (desarrollo):
     composer require laravel/telescope
     php artisan telescope:install
     php artisan migrate

Dashboard de métricas (usar Telescope o crear propio):
  - Requests por minuto
  - Tiempo de respuesta promedio
  - Tasa de errores
  - Endpoints más usados

Beneficio: Mejor debugging, identificación de cuellos de botella, monitoreo proactivo, alertas tempranas.


================================================================================
PRIORIDAD BAJA - MEJORAS FUTURAS
================================================================================

16. WEBHOOKS O NOTIFICACIONES PUSH
--------------------------------------------------------------------------------
Solución: Implementar webhooks para eventos importantes:
  - Cliente creado/actualizado
  - Reserva confirmada/cancelada
  - Nueva actividad asignada

O implementar notificaciones push (FCM/APNS).

Beneficio: Actualizaciones en tiempo real, menos polling innecesario.


17. WEBSOCKETS PARA ACTUALIZACIONES EN TIEMPO REAL
--------------------------------------------------------------------------------
Solución: Implementar WebSockets:
  - Endpoint: WS /cazador/notifications
  - Eventos: reservation.created, reservation.updated, unit.status_changed, etc.

Beneficio: Actualizaciones instantáneas, mejor experiencia, menos polling.


18. VERSIONADO DE API
--------------------------------------------------------------------------------
Solución: Implementar versionado de API:
  - URL: /api/v1/cazador/... o header: Accept: application/vnd.api+json;version=1
  - Documentar cambios entre versiones
  - Mantener versiones anteriores por compatibilidad

Beneficio: Evolución sin romper clientes, mejor control de cambios.


19. ENDPOINT DE SINCRONIZACIÓN
--------------------------------------------------------------------------------
Solución Laravel: Endpoint con timestamps y soft deletes

Implementación:
  a) Asegurar que modelos tienen updated_at y usan SoftDeletes:
     use Illuminate\Database\Eloquent\SoftDeletes;
     
     class Client extends Model {
         use SoftDeletes;
         // updated_at ya existe por defecto
     }

  b) Crear SyncController:
     app/Http/Controllers/Cazador/SyncController.php
     
     public function sync(Request $request) {
         $since = $request->input('since', now()->subDays(7)->toIso8601String());
         $sinceDate = Carbon::parse($since);
         
         $userId = auth()->id();
         
         return response()->json([
             'data' => [
                 'clients' => [
                     'updated' => Client::where('advisor_id', $userId)
                         ->where('updated_at', '>', $sinceDate)
                         ->get(['id', 'updated_at']),
                     'deleted' => Client::onlyTrashed()
                         ->where('advisor_id', $userId)
                         ->where('deleted_at', '>', $sinceDate)
                         ->pluck('id'),
                 ],
                 'reservations' => [
                     'updated' => Reservation::where('advisor_id', $userId)
                         ->where('updated_at', '>', $sinceDate)
                         ->get(['id', 'updated_at']),
                     'deleted' => Reservation::onlyTrashed()
                         ->where('advisor_id', $userId)
                         ->where('deleted_at', '>', $sinceDate)
                         ->pluck('id'),
                 ],
                 // ... más recursos
             ],
             'sync_timestamp' => now()->toIso8601String(),
         ]);
     }

  c) Agregar ruta:
     Route::get('/cazador/sync', [SyncController::class, 'sync']);

Ejemplo de uso:
  GET /cazador/sync?since=2025-01-01T00:00:00Z

Respuesta:
{
  "data": {
    "clients": {
      "updated": [{"id": 1, "updated_at": "2025-01-09T10:00:00Z"}, ...],
      "deleted": [5, 7, 9]
    },
    "reservations": {...}
  },
  "sync_timestamp": "2025-01-09T12:00:00Z"
}

Beneficio: Sincronización eficiente después de offline, menos datos transferidos, mejor soporte offline.


20. ENDPOINTS DE EXPORTACIÓN
--------------------------------------------------------------------------------
Solución: Crear endpoints de exportación:
  - GET /cazador/clients/export?format=csv&filters=...
  - GET /cazador/reservations/export?format=pdf&filters=...
  - GET /cazador/reports/sales?format=xlsx&date_from=...&date_to=...

Soporte para formatos: CSV, PDF, Excel.
Procesamiento asíncrono para exportaciones grandes (retornar job ID).

Beneficio: Funcionalidad de exportación, reportes personalizados.


21. SEGURIDAD ADICIONAL
--------------------------------------------------------------------------------
Solución: Implementar medidas de seguridad:
  - Rate limiting por IP y usuario
  - Validación estricta de inputs (sanitización)
  - Protección CSRF para operaciones críticas
  - Validación de tamaño de archivos (máx 10MB para imágenes)
  - Escaneo de malware en archivos subidos
  - Logging de intentos de acceso no autorizados
  - Rotación automática de tokens JWT
  - Blacklist de tokens revocados

Beneficio: Mayor seguridad, prevención de ataques, cumplimiento de estándares.


22. ENDPOINTS DE HEALTH CHECK Y STATUS
--------------------------------------------------------------------------------
Solución Laravel: Crear HealthController con checks de servicios

Implementación:
  a) Crear HealthController:
     app/Http/Controllers/HealthController.php
     
     class HealthController extends Controller {
         public function health() {
             return response()->json([
                 'status' => 'healthy',
                 'timestamp' => now()->toIso8601String(),
             ]);
         }
         
         public function status() {
             $checks = [
                 'database' => $this->checkDatabase(),
                 'cache' => $this->checkCache(),
                 'storage' => $this->checkStorage(),
                 'queue' => $this->checkQueue(),
             ];
             
             $allHealthy = collect($checks)->every(fn($check) => $check['status'] === 'ok');
             
             return response()->json([
                 'status' => $allHealthy ? 'healthy' : 'degraded',
                 'checks' => $checks,
                 'uptime' => $this->getUptime(),
                 'version' => config('app.version', '1.4.0'),
                 'timestamp' => now()->toIso8601String(),
             ], $allHealthy ? 200 : 503);
         }
         
         protected function checkDatabase() {
             try {
                 DB::connection()->getPdo();
                 return ['status' => 'ok', 'message' => 'Connected'];
             } catch (\Exception $e) {
                 return ['status' => 'error', 'message' => $e->getMessage()];
             }
         }
         
         protected function checkCache() {
             try {
                 Cache::put('health_check', 'ok', 1);
                 $value = Cache::get('health_check');
                 return ['status' => $value === 'ok' ? 'ok' : 'error', 'message' => 'Operational'];
             } catch (\Exception $e) {
                 return ['status' => 'error', 'message' => $e->getMessage()];
             }
         }
         
         protected function checkStorage() {
             try {
                 Storage::disk('local')->put('health_check.txt', 'ok');
                 $value = Storage::disk('local')->get('health_check.txt');
                 Storage::disk('local')->delete('health_check.txt');
                 return ['status' => $value === 'ok' ? 'ok' : 'error', 'message' => 'Writable'];
             } catch (\Exception $e) {
                 return ['status' => 'error', 'message' => $e->getMessage()];
             }
         }
         
         protected function checkQueue() {
             // Verificar conexión a queue
             return ['status' => 'ok', 'message' => 'Connected'];
         }
         
         protected function getUptime() {
             // Usar sistema operativo o guardar timestamp de inicio
             return time() - filemtime(base_path('bootstrap/cache/config.php'));
         }
         
         public function metrics() {
             // Solo para admins
             $this->authorize('view-metrics');
             
             return response()->json([
                 'requests_per_minute' => $this->getRequestsPerMinute(),
                 'average_response_time' => $this->getAverageResponseTime(),
                 'error_rate' => $this->getErrorRate(),
                 'top_endpoints' => $this->getTopEndpoints(),
             ]);
         }
     }

  b) Agregar rutas (sin autenticación para /health):
     Route::get('/health', [HealthController::class, 'health']);
     Route::get('/status', [HealthController::class, 'status']);
     Route::get('/metrics', [HealthController::class, 'metrics'])
         ->middleware(['auth:api', 'can:view-metrics']);

Respuesta ejemplo:
{
  "status": "healthy",
  "checks": {
    "database": {"status": "ok", "message": "Connected"},
    "cache": {"status": "ok", "message": "Operational"},
    "storage": {"status": "ok", "message": "Writable"},
    "queue": {"status": "ok", "message": "Connected"}
  },
  "uptime": 86400,
  "version": "1.4.0",
  "timestamp": "2025-01-09T12:00:00Z"
}

Beneficio: Monitoreo de salud del sistema, detección temprana de problemas, integración con monitoreo externo.


================================================================================
MÉTRICAS DE ÉXITO ESPERADAS
================================================================================

Backend:
  - Reducción de requests al dashboard: 75% (de 4 a 1)
  - Reducción de tamaño de respuestas: 60-80% (con compresión)
  - Reducción de queries a BD: 30-50% (con índices y caché)
  - Mejora en tiempo de respuesta: 20-40% (con optimizaciones)
  - Mejor uso de ancho de banda: 50-70% (con compresión y caché)

Frontend:
  - Reducción de tiempo de carga inicial: 30-50%
  - Reducción de llamadas a API: 40-60% (con caché)
  - Mejora en FPS durante scroll: 10-20%
  - Reducción de crashes: 50%+ (mejor manejo de errores)


================================================================================
NOTAS IMPORTANTES
================================================================================

1. ACTUALIZAR DOCUMENTACIÓN ENDPOINTS.md (URGENTE):
   
   a) Agregar create_type al GET /clients (línea 40-45):
      - El frontend ya usa este parámetro (ClientService.getClients)
      - Falta documentarlo en ENDPOINTS.md
      - Agregar: `create_type` (string, opcional) - Filtrar por tipo de creación: 'propio' o 'datero'
   
   b) Documentar códigos de error:
      - Agregar sección de "Códigos de Error HTTP" con ejemplos
      - Documentar formato estándar de errores
      - Incluir todos los códigos posibles (400, 401, 403, 404, 422, 429, 500)
   
   c) Documentar headers de respuesta:
      - Si existen headers de caché, documentarlos
      - Si hay compresión, mencionarlo
      - Headers de rate limiting si existen
   
   d) Agregar ejemplos de respuestas:
      - Ejemplos de éxito y error para cada endpoint
      - Formato de paginación
      - Formato de relaciones incluidas

2. Todas las mejoras deben mantener compatibilidad hacia atrás cuando sea posible.

3. Los cambios deben ser documentados en ENDPOINTS.md después de implementarlos.

4. Se recomienda implementar las mejoras de Alta Prioridad primero, ya que
   tienen el mayor impacto inmediato.

5. Para cambios que requieren migración de datos o cambios estructurales,
   planificar ventanas de mantenimiento apropiadas.

6. Considerar el impacto en otros clientes (web, otros móviles) antes de
   implementar cambios breaking.

7. Implementar pruebas de carga para validar mejoras de rendimiento.

8. Monitorear métricas antes y después de implementar cada mejora.

9. VERIFICAR IMPLEMENTACIÓN: Algunas funcionalidades pueden estar ya 
   implementadas pero no documentadas. Revisar código del backend antes de
   implementar desde cero.


================================================================================
NOTAS ESPECÍFICAS PARA LARAVEL 12
================================================================================

1. Laravel 12 usa PHP 8.2+ - Asegurar que todas las dependencias sean compatibles.

2. Usar características nuevas de Laravel 12:
   - Model::casts() para type casting
   - Nuevos métodos de Query Builder
   - Mejoras en Eloquent

3. Configurar correctamente:
   - config/cache.php - Para Redis/Memcached
   - config/filesystems.php - Para S3/Storage
   - config/queue.php - Para jobs asíncronos

4. Usar Artisan commands para tareas comunes:
   - php artisan cache:clear
   - php artisan config:cache
   - php artisan route:cache
   - php artisan view:cache

5. Considerar usar Laravel Horizon para monitoreo de queues (Redis).

6. Usar Laravel Sanctum para autenticación API (ya implementado probablemente).

7. Implementar API Resources para formateo consistente de respuestas.

8. Usar Form Requests para validación y autorización.

9. Considerar usar Laravel Dusk para pruebas E2E de API.

10. Documentar cambios en ENDPOINTS.md después de implementar.


================================================================================
COMANDOS ÚTILES PARA IMPLEMENTACIÓN
================================================================================

# Crear controllers
php artisan make:controller Cazador/DashboardController
php artisan make:controller Cazador/ValidationController
php artisan make:controller Cazador/SyncController
php artisan make:controller HealthController

# Crear requests
php artisan make:request Cazador/ReservationIndexRequest
php artisan make:request Cazador/ValidateClientRequest

# Crear resources
php artisan make:resource ClientResource
php artisan make:resource PaginatedResource

# Crear middleware
php artisan make:middleware CacheHeaders
php artisan make:middleware RateLimitHeaders
php artisan make:middleware LogRequest

# Crear services
php artisan make:service ImageService

# Crear jobs
php artisan make:job ProcessReservationImage

# Crear migrations
php artisan make:migration add_indexes_to_optimize_queries
php artisan make:migration add_image_urls_to_reservations

# Crear traits
# (crear manualmente app/Traits/LoadsRelations.php)


================================================================================
ACCIÓN INMEDIATA REQUERIDA
================================================================================

1. ACTUALIZAR ENDPOINTS.md (URGENTE):
   - Agregar create_type al GET /clients (línea 40-45)
     Query: create_type (string, opcional) - Filtrar por tipo de creación (propio/datero)
   - Documentar todos los códigos de error posibles con ejemplos
   - Agregar ejemplos de respuestas de error en formato estándar
   - Documentar headers de respuesta (Cache-Control, ETag, etc. si existen)

2. VERIFICAR IMPLEMENTACIÓN ANTES DE DESARROLLAR:
   - Revisar código del backend para confirmar qué está implementado
   - Verificar si los filtros de reservas ya están implementados pero no documentados
   - Confirmar si hay compresión de respuestas configurada en Nginx/Apache
   - Verificar si hay headers de caché en las respuestas actuales

3. PRIORIZAR IMPLEMENTACIÓN:
   - Alta Prioridad #1: Agregar filtros a GET /reservations (confirmado que falta según ENDPOINTS.md)
   - Alta Prioridad #2: Crear GET /dashboard/stats (confirmado que no existe)
   - Alta Prioridad #5: Documentar errores (mejorar documentación existente)
   - Media Prioridad: Actualizar documentación de create_type en GET /clients


================================================================================
CONTACTO Y SOPORTE
================================================================================

Para preguntas o aclaraciones sobre estas recomendaciones, contactar al equipo
de desarrollo móvil o revisar el plan completo en:
  .cursor/plans/optimización_de_rendimiento_y_ux_b2d4483c.plan.md

Documentación Laravel 12: https://laravel.com/docs/12.x
Documentación API actual: ENDPOINTS.md (revisar antes de implementar)

================================================================================
